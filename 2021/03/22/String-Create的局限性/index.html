<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>String.Create的局限性 | bleatingsheep 的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">String.Create的局限性</h1><a id="logo" href="/.">bleatingsheep 的博客</a><p class="description"></p></div><div id="nav-menu"><a href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-4-4"><div class="content_container"><div class="post"><h1 class="post-title">String.Create的局限性</h1><div class="post-meta">2021-03-22</div><a class="disqus-comment-count" href="/2021/03/22/String-Create%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7/#vcomment"><span class="valine-comment-count" data-xid="/2021/03/22/String-Create%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7/"></span><span> 条评论</span></a><div class="post-content"><h2 id="String-Create-介绍"><a href="#String-Create-介绍" class="headerlink" title="String.Create 介绍"></a><code>String.Create</code> 介绍</h2><p>.NET Core 2.1 和 .NET Standard 2.1 新增了 <code>Span&lt;T&gt;</code>、<code>Memory&lt;T&gt;</code> 等非常方便的操作内存的方式，同时增加了如 <code>String.Create()</code> 这种高效的创建字符串的方法。最近在写 <a target="_blank" rel="noopener" href="https://github.com/rcnbapp/RCNB.csharp">RCNB</a> 终于得以一试，结果发现了这个方法的许多局限之处。</p>
<span id="more"></span>

<p>我们先看一个这个方法的定义。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">Create</span>&lt;<span class="title">TState</span>&gt;(<span class="params"><span class="built_in">int</span> length, TState state, SpanAction&lt;<span class="built_in">char</span>, TState&gt; action</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>首先这是一个泛型方法，接受一个 <code>TState</code> 实例并直接传给 <code>action</code>。我们看一下 <code>SpanAction&lt;char, TState&gt;</code> 的定义。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">SpanAction</span>&lt;<span class="title">T</span>, <span class="keyword">in</span> <span class="title">TArg</span>&gt;(<span class="params">Span&lt;T&gt; span, TArg arg</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>为什么不直接用 <code>Action&lt;in T1, in T2&gt;</code> 呢？因为 <code>Span&lt;T&gt;</code> 是 <code>readonly ref struct</code>，不能用于泛型参数。问题就出在这一点，由于它不能用在泛型参数上，给 <code>String.Create</code> 也带来了一些局限，只能用很麻烦的方式绕过。</p>
<h2 id="String-Create-的局限性"><a href="#String-Create-的局限性" class="headerlink" title="String.Create 的局限性"></a><code>String.Create</code> 的局限性</h2><p>我给 RCNB 编码设计了这么一个 API 方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">ToRcnbString</span>(<span class="params">ReadOnlySpan&lt;<span class="built_in">byte</span>&gt; inArray</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这个方法接收一个 <code>ReadOnlySpan&lt;byte&gt;</code>，将基用 RCNB 编码，并返回结果字符串。在底层，我已经实现了编码方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EncodeRcnb</span>(<span class="params">Span&lt;<span class="built_in">char</span>&gt; resultArray, ReadOnlySpan&lt;<span class="built_in">byte</span>&gt; inArray</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我底层的方法从 <code>ReadOnlySpan&lt;byte&gt; inArray</code> 中读取数据，并把编码好的字符串存入 <code>Span&lt;char&gt; resultArray</code> 中。我本以为，.NET Core 2.1 新增的 <code>Span&lt;T&gt;</code> 等结构足够强大，可以让我把任何传入参数转换成这两个东西，并进行 RCNB 编码。于是我就先这么写：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">ToRcnbString</span>(<span class="params">ReadOnlySpan&lt;<span class="built_in">byte</span>&gt; inArray</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> length = CalculateLength(inArray);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>.Create(length, inArray, (span, a) =&gt; EncodeRcnb(span, a.Span));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路是，先计算出结果字符串的长度，再把 <code>inArray</code> 传给 <code>String.Create</code> 方法，调用 <code>EncodeRcnb</code> 方法进行编码。</p>
<p>但我得到一个错误。</p>
<img src="/2021/03/22/String-Create%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7/cs0306-1.5x.png" class="">

<p>意思是 <code>ReadOnlySpan&lt;byte&gt;</code> 不能被用作类型参数。还记得 <code>String.Create</code> 的定义吗？传入参数的类型是用泛型参数 <code>TState</code> 确定的，自然会受到这个限制。</p>
<h2 id="NET-内部的解决方式"><a href="#NET-内部的解决方式" class="headerlink" title=".NET 内部的解决方式"></a>.NET 内部的解决方式</h2><p>如果你用 .NET 编码或解码过 base64，你应该会发现 <code>System.Convert</code> 类有这样一个方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">ToBase64String</span>(<span class="params">ReadOnlySpan&lt;<span class="built_in">byte</span>&gt; bytes, Base64FormattingOptions options = Base64FormattingOptions.None</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这个方法也接收 <code>ReadOnlySpan&lt;byte&gt;</code>，返回 <code>String</code>，它是怎么实现的呢？我们来看一看 <a target="_blank" rel="noopener" href="https://github.com/dotnet/runtime/blob/11868166a541b2746eb86b8812302bd65ecfd2f7/src/libraries/System.Private.CoreLib/src/System/Convert.cs#L2349">.NET 实现源码</a>。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">ToBase64String</span>(<span class="params">ReadOnlySpan&lt;<span class="built_in">byte</span>&gt; bytes, Base64FormattingOptions options = Base64FormattingOptions.None</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (options &lt; Base64FormattingOptions.None || options &gt; Base64FormattingOptions.InsertLineBreaks)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(SR.Format(SR.Arg_EnumIllegalVal, (<span class="built_in">int</span>)options), <span class="keyword">nameof</span>(options));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bytes.Length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>.Empty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> insertLineBreaks = (options == Base64FormattingOptions.InsertLineBreaks);</span><br><span class="line">    <span class="built_in">string</span> result = <span class="built_in">string</span>.FastAllocateString(ToBase64_CalculateAndValidateOutputLength(bytes.Length, insertLineBreaks));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">fixed</span> (<span class="built_in">byte</span>* bytesPtr = &amp;MemoryMarshal.GetReference(bytes))</span><br><span class="line">        <span class="keyword">fixed</span> (<span class="built_in">char</span>* charsPtr = result)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> charsWritten = ConvertToBase64Array(charsPtr, bytesPtr, <span class="number">0</span>, bytes.Length, insertLineBreaks);</span><br><span class="line">            Debug.Assert(result.Length == charsWritten, <span class="string">$&quot;Expected <span class="subst">&#123;result.Length&#125;</span> == <span class="subst">&#123;charsWritten&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，.NET 实现上首先用了 <code>string.FastAllocateString</code> 快速分配字符串所需的内存，然后用 <code>fixed (byte* bytesPtr = &amp;MemoryMarshal.GetReference(bytes))</code> 获取 <code>bytes</code> 的指针。最早实现 <code>ConvertToBase64Array</code> 时还没有 <code>Span&lt;T&gt;</code>，我认为转换成指针是为了复用以前的代码。问题是 <code>string.FastAllocateString</code> 是个内部方法，我无法调用。尽管有人问了 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/19992144/how-can-i-implement-stringbuilder-and-or-call-string-fastallocatestring">如何调用这个方法</a>，但是是用反射强行调用的，无法保证所有版本 .NET 都是这么实现的，不太好。</p>
<h2 id="尝试解决问题"><a href="#尝试解决问题" class="headerlink" title="尝试解决问题"></a>尝试解决问题</h2><h3 id="转换成-ReadOnlyMemory-lt-T-gt"><a href="#转换成-ReadOnlyMemory-lt-T-gt" class="headerlink" title="转换成 ReadOnlyMemory&lt;T&gt;"></a>转换成 <code>ReadOnlyMemory&lt;T&gt;</code></h3><p>我首先想到的是转换成 <code>ReadOnlyMemory&lt;T&gt;</code>。我知道 <code>Memory&lt;T&gt;</code> 及 <code>ReadOnlyMemory&lt;T&gt;</code> 可以转换成 <code>Span&lt;T&gt;</code> 和 <code>ReadOnlySpan&lt;T&gt;</code>，也知道反过来会出现问题。</p>
<h4 id="ReadOnlyMemory-lt-T-gt-、Memory-lt-T-gt-、ReadOnlySpan-lt-T-gt-、Span-lt-T-gt-的关系"><a href="#ReadOnlyMemory-lt-T-gt-、Memory-lt-T-gt-、ReadOnlySpan-lt-T-gt-、Span-lt-T-gt-的关系" class="headerlink" title="ReadOnlyMemory&lt;T&gt;、Memory&lt;T&gt;、ReadOnlySpan&lt;T&gt;、Span&lt;T&gt; 的关系"></a><code>ReadOnlyMemory&lt;T&gt;</code>、<code>Memory&lt;T&gt;</code>、<code>ReadOnlySpan&lt;T&gt;</code>、<code>Span&lt;T&gt;</code> 的关系</h4><p>首先，<code>ReadOnlySpan&lt;T&gt;</code>、<code>Span&lt;T&gt;</code> 是用 <code>readonly</code> 修饰的 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct#ref-struct"><code>ref struct</code></a>。<code>ref struct</code> 有诸多限制，而这些限制可以提升性能和代码安全性。例如，我们可以安全地编写下面的代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Span&lt;<span class="built_in">byte</span>&gt; bytes = <span class="keyword">stackalloc</span> <span class="built_in">byte</span>[<span class="number">2000</span>];</span><br></pre></td></tr></table></figure>

<p>这段代码从栈上分配 2000 字节，存储在 <code>bytes</code> 中。在 C 或 C++ 中，你可能不小心把栈上指针赋值到别处，或者当成返回值返回，导致稍后可能非法访问。而在 C# 中，如果你用了 <code>Span&lt;T&gt;</code>，由于本身的限制，你无法轻易把它传到别处，这样就可以在不牺牲安全性的前提下提升性能。</p>
<p>再看 <code>ReadOnlyMemory&lt;T&gt;</code> 和 <code>Memory&lt;T&gt;</code>。它们只是普通的结构体，只是用了 <code>readonly</code> 修饰。你完全可以把它随便赋值或者返回到别处。</p>
<p>如果 <code>Span&lt;T&gt;</code> 可以随随便便转换成 <code>Memory&lt;T&gt;</code>，你再把它传到别处，万一那个 <code>Span&lt;T&gt;</code> 是栈上分配的，不就带来不安全访问了吗？所以 <code>Span&lt;T&gt;</code> 是不能随随便便转换成 <code>Memory&lt;T&gt;</code> 的，只读版本亦然。</p>
<h4 id="NET-中其他操作内存的方法"><a href="#NET-中其他操作内存的方法" class="headerlink" title=".NET 中其他操作内存的方法"></a>.NET 中其他操作内存的方法</h4><p>与上面四个 <code>struct</code> 一起到来的，还有操作这些结构体的方法，比如 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.memorymarshal?view=net-5.0"><code>System.Runtime.InteropServices.MemoryMarshal</code></a> 类。<code>MemoryMarshal</code> 类包含一些操作内存的方法，而这些方法看上去并不是那么安全。</p>
<p>例如 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.memorymarshal.asbytes?view=net-5.0"><code>AsBytes</code></a> 方法，可以把任意类型 <code>T</code> 的 <code>Span&lt;T&gt;</code> 转换成 <code>Span&lt;byte&gt;</code>。例如要生成随机 <code>uint</code> 时，就<a target="_blank" rel="noopener" href="https://github.com/dotnet/runtime/blob/90010d055393074123c7e3198a6eda150624f30c/src/libraries/System.Security.Cryptography.Algorithms/src/System/Security/Cryptography/RandomNumberGenerator.cs#L135">可以把 <code>Span&lt;uint&gt;</code> 转换成 <code>Span&lt;bytes&gt;</code> 放置生成的随机字节</a>。</p>
<p>此外还有 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.memorymarshal.asmemory?view=net-5.0"><code>AsMemory</code></a> 可以把只读的 <code>ReadOnlyMemory&lt;T&gt;</code> 变成可写的 <code>Memory&lt;T&gt;</code>，同样可能带来潜在的安全问题。</p>
<p>除了 <code>MemoryMarshal</code>，<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.unsafe?view=net-5.0"><code>System.Runtime.CompilerServices.Unsafe</code></a> 类也包含一些操作内存的方法。</p>
<p>遗憾的是，这两个类都没有把 <code>ReadOnlySpan&lt;T&gt;</code> 转换成 <code>ReadOnlyMemory&lt;T&gt;</code> 的方法。</p>
<h3 id="借助指针"><a href="#借助指针" class="headerlink" title="借助指针"></a>借助指针</h3><p>但问题还是要解决的，我不希望无意义地复制内存。</p>
<p>我首先想到的是把指针传入 <code>String.Create</code> 方法。我先开启了 unsafe 编译，再把方法定义前面加上 <code>unsafe</code>。</p>
<p>上面的 base64 编码的源码解释了如何从 <code>ReadOnlySpan&lt;T&gt;</code> 中提取 <code>T</code> 的指针 <code>T*</code>。<a target="_blank" rel="noopener" href="https://stackoverflow.com/a/54257716">此外还有别的方法提取</a>，只要保证正确地 <code>fixed</code> 了就行。由于我们需要指针和长度两个参数，我们把它形成一个元组，传入匿名方法，并在匿名方法里构造出 <code>ReadOnlySpan&lt;byte&gt;</code>。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">unsafe</span> <span class="built_in">string</span> <span class="title">ToRcnbString</span>(<span class="params">ReadOnlySpan&lt;<span class="built_in">byte</span>&gt; inArray</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> length = CalculateLength(inArray);</span><br><span class="line">    <span class="keyword">fixed</span> (<span class="built_in">byte</span>* data = inArray)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>.Create(length,</span><br><span class="line">            (data, inArray.Length),</span><br><span class="line">            (span, a) =&gt; EncodeRcnb(span, <span class="keyword">new</span> ReadOnlySpan&lt;<span class="built_in">byte</span>&gt;(a.data, a.Length)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果我们在 <code>(data, inArray.Length),</code> 这一行的 <code>data</code> 处遇到一个错误，说：</p>
<img src="/2021/03/22/String-Create%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7/pointer-1.5x.png" class="">

<p>也就是说，除了 <code>ref struct</code>，指针类型也不能用作泛型参数。</p>
<p>然后我想到，指针也不行，那 <code>ReadOnlyMemory&lt;T&gt;</code> 可以传入吗，它就是普通的 <code>struct</code>。遗憾的是，尽管可以用指定的指针和长度创建 <code>Span&lt;T&gt;</code>，<code>Memory&lt;T&gt;</code> 及只读版本却没有用指针创建的构造方法。</p>
<p>然后我想，<code>ReadOnlyMemory&lt;T&gt;</code> 没有合适的构造方法，那我自己定义一个 <code>struct</code> 总可以了吧。于是就<a target="_blank" rel="noopener" href="https://github.com/rcnbapp/RCNB.csharp/blob/a5190d31f220e02df0aa76b0c22cde6024b8441d/RCNB/RcnbConvert.cs#L120">写成了这样</a>：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">unsafe</span> <span class="built_in">string</span> <span class="title">ToRcnbString</span>(<span class="params">ReadOnlySpan&lt;<span class="built_in">byte</span>&gt; inArray</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> length = CalculateLength(inArray);</span><br><span class="line">    <span class="keyword">fixed</span> (<span class="built_in">byte</span>* data = inArray)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>.Create(length,</span><br><span class="line">            <span class="keyword">new</span> ByteMemoryMedium(data, inArray.Length),</span><br><span class="line">            (span, a) =&gt; EncodeRcnb(span, <span class="keyword">new</span> ReadOnlySpan&lt;<span class="built_in">byte</span>&gt;(a.Pointer, a.Length)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">unsafe</span> <span class="keyword">readonly</span> <span class="keyword">struct</span> ByteMemoryMedium</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ByteMemoryMedium</span>(<span class="params"><span class="built_in">byte</span>* pointer, <span class="built_in">int</span> length</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Pointer = pointer;</span><br><span class="line">        Length = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">byte</span>* Pointer &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Length &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我自己定义了一个 <code>unsafe struct</code>，接受指针和长度，并把这个结构的实例传入 <code>String.Create</code>，终于达成目标。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>.NET Core 2.1 引入的 <code>ref struct</code> 和 <code>Span&lt;T&gt;</code> 等类型为操作内存提供了相当程度的便利。上面没细说的 <code>EncodeRcnb</code> 方法就充分利用了这些类型。同时引入的 <code>String.Create</code> 方法可以减少创建字符串时的内存分配，尽管它用起来有很多局限。我希望 C# 未来的版本可以放宽 <code>ref struct</code> 的条件，以便 <code>Span&lt;T&gt;</code> 可以传入 <code>String.Create</code> 方法。<del>希望 .NET 基金会不要不识抬举。</del></p>
<script src="/scripts/image-scale.js"></script></div><div class="tags"><a href="/tags/C/"><i class="fa fa-tag"></i>C#</a><a href="/tags/NET/"><i class="fa fa-tag"></i>.NET</a></div><div class="post-nav"><a class="pre" href="/2021/03/24/%E7%BB%99Chromium-Edge%E8%AE%BE%E7%BD%AE%E4%BB%BB%E6%84%8F%E7%BC%A9%E6%94%BE/">给Chromium Edge设置任意缩放</a><a class="next" href="/2021/03/22/NET%E4%B8%80%E5%A4%84%E5%A5%87%E6%80%AA%E7%9A%84%E6%B5%8B%E8%AF%95%E6%9C%AA%E8%BF%90%E8%A1%8C/">.NET一处奇怪的测试未运行</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == 'true' ? true : false;
var verify = 'false' == 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'eF5widAEDbOaAndcDJGQp7Rh-gzGzoHsz',
  appKey:'WyOY5xy1Lo6xy1FLLTbpkwEM',
  placeholder:'',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  path: 'bleatingsheep.org/_posts/String-Create的局限性.md',
  requiredFields: ['nick','mail']
})
</script></div></div></div><div class="pure-u-1 pure-u-md-4-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">bleatingsheep 的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>