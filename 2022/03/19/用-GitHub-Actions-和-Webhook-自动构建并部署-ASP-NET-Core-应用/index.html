<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>用 GitHub Actions 和 Webhook 自动构建并部署 ASP.NET Core 应用 | bleatingsheep 的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/pure/2.1.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/pure/2.1.0/grids-responsive.min.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/toastr.js/2.1.4/toastr.min.js"></script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/toastr.js/2.1.4/toastr.min.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">用 GitHub Actions 和 Webhook 自动构建并部署 ASP.NET Core 应用</h1><a id="logo" href="/.">bleatingsheep 的博客</a><p class="description"></p></div><div id="nav-menu"><a href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-4-4"><div class="content_container"><div class="post"><h1 class="post-title">用 GitHub Actions 和 Webhook 自动构建并部署 ASP.NET Core 应用</h1><div class="post-meta">2022-03-19</div><a class="disqus-comment-count" href="/2022/03/19/%E7%94%A8-GitHub-Actions-%E5%92%8C-Webhook-%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E5%B9%B6%E9%83%A8%E7%BD%B2-ASP-NET-Core-%E5%BA%94%E7%94%A8/#vcomment"><span class="valine-comment-count" data-xid="bleatingsheep.org/_posts/用-GitHub-Actions-和-Webhook-自动构建并部署-ASP-NET-Core-应用.md"></span><span> 条评论</span></a><div class="post-content"><p>最近给自己的直播写了个弹幕后端，基于 ASP.NET Core 和 SignalR，实现非常简单。部署反而比预期麻烦很多，因为我之前自动部署的应用都是静态网站，这次要部署动态应用，就遇到了预料之外的问题。</p>
<p>最终，我选择了用 GitHub Actions 构建并推送到另一分支，然后触发 Webhook，由自己的服务器拉取构建好的新版本并重启应用更新。</p>
<span id="more"></span>

<h2 id="配置-Webhook-服务器"><a href="#配置-Webhook-服务器" class="headerlink" title="配置 Webhook 服务器"></a>配置 Webhook 服务器</h2><p>这种东西当然不要自己写，我选了 <a target="_blank" rel="noopener" href="https://github.com/adnanh/webhook">adnanh&#x2F;webhook</a>。在服务器上下载好，编写一个简单的配置文件并运行，用浏览器或 curl 访问一下，观察日志及脚本副作用确定 Webhook 是否正常工作。</p>
<figure class="highlight yaml"><figcaption><span>hooks.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">redeploy-webhook</span></span><br><span class="line">  <span class="attr">execute-command:</span> <span class="string">&quot;/var/scripts/redeploy.sh&quot;</span></span><br><span class="line">  <span class="attr">command-working-directory:</span> <span class="string">&quot;/var/webhook&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/path/to/webhook -hooks hooks.yaml -verbose</span><br></pre></td></tr></table></figure>

<h2 id="配置-GitHub-Actions"><a href="#配置-GitHub-Actions" class="headerlink" title="配置 GitHub Actions"></a>配置 GitHub Actions</h2><p>只需要用 Actions 构建并推送到其他分支即可，可以参考<a target="_blank" rel="noopener" href="https://github.com/b11p/bleatingsheep.Danmaku/blob/75b3ec4519ebf7789ec1533d896e14e21f8b0fa6/.github/workflows/dotnet.yml">此文件</a>，本文不再赘述。</p>
<h2 id="配置-GitHub-Webhook"><a href="#配置-GitHub-Webhook" class="headerlink" title="配置 GitHub Webhook"></a>配置 GitHub Webhook</h2><p>在仓库设置中添加 Webhook，“Payload URL”填写 http:&#x2F;&#x2F;your-server:9000&#x2F;hooks&#x2F;redeploy-webhook，其中把“your-server”替换成你服务器的 IP 或域名，最后一部分改为你设置的 Webhook ID。“Content type”选择“application&#x2F;json”，“Secret”填写一个秘密字符串，在下面选择“Just the push event.”。</p>
<img src="webhook-2.25x.png" width=496/>

<p>添加后，GitHub 会自动触发一次，配置正确的情况下会出现绿勾，如果出现错误，请排查配置问题。</p>
<img src="webhook-delivers-2.25x.png" width=792>

<p>确认配置无误后，随便往存储库 push 点什么东西，触发 CI。回到管理 Webhook 页面，应该会看到又触发了两次 Webhook，一次是 push 代码，一次是 push 构建结果。Webhook 推送数据会用作 Webhook Server 配置的参考。</p>
<h2 id="更新-Webhook-Server-配置"><a href="#更新-Webhook-Server-配置" class="headerlink" title="更新 Webhook Server 配置"></a>更新 Webhook Server 配置</h2><p>参考推送内容和 adnanh&#x2F;webhook 的文档，更新 Webhook Server 配置，确保只在构建结果分支 push 时触发脚本，同时对传入数据进行验证，防止脚本被恶意触发。</p>
<p>下面是我的配置：</p>
<figure class="highlight yaml"><figcaption><span>hooks.yaml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">deploy-danmaku</span></span><br><span class="line">  <span class="attr">execute-command:</span> <span class="string">&quot;/home/user/danmaku.sh&quot;</span></span><br><span class="line">  <span class="attr">command-working-directory:</span> <span class="string">&quot;/home/user&quot;</span></span><br><span class="line">  <span class="attr">pass-arguments-to-command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">source:</span> <span class="string">payload</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">repository.clone_url</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">source:</span> <span class="string">payload</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">head_commit.id</span></span><br><span class="line">  <span class="attr">trigger-rule:</span></span><br><span class="line">    <span class="attr">and:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">payload-hmac-sha1</span></span><br><span class="line">          <span class="attr">secret:</span> <span class="string">&lt;</span> <span class="string">here</span> <span class="string">is</span> <span class="string">my</span> <span class="string">secret</span> <span class="string">&gt;</span></span><br><span class="line"><span class="string">          parameter:</span></span><br><span class="line"><span class="string">            source: header</span></span><br><span class="line"><span class="string">            name: X-Hub-Signature</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">value</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">push</span></span><br><span class="line">          <span class="attr">parameter:</span></span><br><span class="line">            <span class="attr">source:</span> <span class="string">header</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">X-GitHub-Event</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">match:</span></span><br><span class="line">          <span class="attr">type:</span> <span class="string">value</span></span><br><span class="line">          <span class="attr">value:</span> <span class="string">refs/heads/build</span></span><br><span class="line">          <span class="attr">parameter:</span></span><br><span class="line">            <span class="attr">source:</span> <span class="string">payload</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">ref</span></span><br></pre></td></tr></table></figure>

<p>此配置的的意图是，当“build”分支有“push”事件，并且通过 HMAC SHA1 验证时，才触发脚本，同时从 Webhook 推送中提取存储库链接和 commit ID 信息传入脚本。</p>
<h2 id="编写更新脚本"><a href="#编写更新脚本" class="headerlink" title="编写更新脚本"></a>编写更新脚本</h2><p>下面是我的脚本：</p>
<figure class="highlight sh"><figcaption><span>danmaku.sh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># omitting stopping old server</span></span><br><span class="line"></span><br><span class="line">DEPLOY_DIR=$(<span class="built_in">realpath</span> ~/danmaku)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> != <span class="string">&quot;&quot;</span> ] &amp;&amp; [ <span class="string">&quot;<span class="variable">$2</span>&quot;</span> != <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Webhook mode.&quot;</span></span><br><span class="line">    REPO_URL=<span class="variable">$1</span></span><br><span class="line">    COMMIT_ID=<span class="variable">$2</span></span><br><span class="line">    <span class="built_in">mkdir</span> -p <span class="variable">$DEPLOY_DIR</span></span><br><span class="line">    <span class="built_in">cd</span> <span class="variable">$DEPLOY_DIR</span></span><br><span class="line">    git init</span><br><span class="line">    <span class="keyword">if</span> git remote | grep -q -P <span class="string">&#x27;^b11p-git-pages$&#x27;</span>; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Cleaning old remote&quot;</span></span><br><span class="line">        git remote remove b11p-git-pages</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    git remote add b11p-git-pages <span class="string">&quot;<span class="variable">$REPO_URL</span>&quot;</span></span><br><span class="line">    git fetch -v --set-upstream b11p-git-pages --depth 1 <span class="string">&quot;<span class="variable">$COMMIT_ID</span>&quot;</span></span><br><span class="line">    git reset --hard <span class="string">&quot;<span class="variable">$COMMIT_ID</span>&quot;</span></span><br><span class="line">    git reflog expire --expire-unreachable=all --all --verbose</span><br><span class="line">    git gc --prune=all</span><br><span class="line">    git remote remove b11p-git-pages</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Not webhook mode.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># omitting start new server</span></span><br></pre></td></tr></table></figure>

<p>此脚本会自动拉取对应 commit，并重新启动服务，应用新版本。</p>
<h2 id="用-systemd-自动启动-Webhook-Server"><a href="#用-systemd-自动启动-Webhook-Server" class="headerlink" title="用 systemd 自动启动 Webhook Server"></a>用 systemd 自动启动 Webhook Server</h2><p>下面，用你喜欢的编辑器创建并编辑“~&#x2F;.config&#x2F;systemd&#x2F;user&#x2F;webhook.service”，编写 systemd 服务，以便开机自动启动 Webhook Server。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Webhooks</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5s</span><br><span class="line"></span><br><span class="line">WorkingDirectory=/home/user/webhooks</span><br><span class="line">ExecStart=/home/user/webhooks/webhook -hooks /home/user/webhooks/hooks.yaml -hotreload</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=default.target</span><br></pre></td></tr></table></figure>

<p>运行下面的命令，启动服务，并设置开机自动启动：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl --user <span class="built_in">enable</span> webhook.service</span><br><span class="line">systemctl --user start webhook.service</span><br><span class="line">loginctl enable-linger</span><br></pre></td></tr></table></figure>

<h2 id="使用配置-HTTPS（可选）"><a href="#使用配置-HTTPS（可选）" class="headerlink" title="使用配置 HTTPS（可选）"></a>使用配置 HTTPS（可选）</h2><p>如果你不想明文 HTTP 通信，可以开启 HTTPS。既可以在 Webhook Server 配置中配置 HTTPS，也可以在反向代理中配置。此处不再赘述。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://davidauthier.com/blog/2017/09/07/deploy-using-github-webhooks/">Deploy using GitHub webhooks</a></li>
<li><a href="/2021/06/20/%E7%94%A8-GitHub-Actions-%E5%92%8C-SSH-%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/" title="用 GitHub Actions 和 SSH 部署静态网站">用 GitHub Actions 和 SSH 部署静态网站</a></li>
<li><a target="_blank" rel="noopener" href="https://www.unixsysadmin.com/systemd-user-services/">systemd user services</a></li>
<li><a target="_blank" rel="noopener" href="https://wiki.archlinux.org/title/systemd/User#Automatic_start-up_of_systemd_user_instances">Automatic start-up of systemd user instances</a></li>
</ul>
<hr>
<h2 id="弯路"><a href="#弯路" class="headerlink" title="弯路"></a>弯路</h2><p>我在解决自动部署问题时走了一些弯路，也做过一些取舍。例如，我考虑过用 CI (GitHub Actions) 构建和在自己的服务器上构建，最终选了 CI。</p>
<!-- 这个任务大体分为三步：构建、传输新版本、应用新版本。 -->

<h3 id="权限不足无法应用新版本"><a href="#权限不足无法应用新版本" class="headerlink" title="权限不足无法应用新版本"></a>权限不足无法应用新版本</h3><p>我一开始想按照之前写的<a href="#">Post not found: 用 GitHub Actions 和 SSH 部署静态网站 《用 GitHub Actions 和 SSH 部署静态网站》</a>中的方式，用 GitHub Actions 构建并推送到另一分支，然后用 Actions SSH 连上服务器，拉取分支。这里和之前不同的地方在于，静态网站拉取分支后可以立刻生效，而动态应用更新还需要重启服务，才能生效。</p>
<p>由于我打算在 Docker 中部署，运行 Docker 命令需要 root 权限（或者需要把用户添加到“docker”组，这相当于给予 root 权限），而我不想给部署用户太高权限。我写了重启相应 Docker 容器的脚本，把所有权改为 root，并用 <code>chmod +s</code> 赋予 SUID 权限<a target="_blank" rel="noopener" href="https://www.cnblogs.com/sparkdev/p/9651622.html">^1</a>。我预期这样就可以让其他用户以 root 权限执行该脚本，但是却还是遇到了权限不足的问题，应该是因为 shell 并没有 SUID 权限。</p>
<p>查阅各种资料，我想到了以下几个解决办法：</p>
<ol>
<li><p>直接用 Azure SignalR Service 一站式解决，啥问题都没了。</p>
<p>贵，我马上就不算学生了，用不了学生额度，怕哪天访问量暴增把我信用卡刷爆，排除。</p>
</li>
<li><p>把部署用户加到 docker 组，或者让 GitHub Actions SSH 连接有权限的用户。</p>
<p>太不安全了，排除。</p>
</li>
<li><p>用编译型语言编写重启服务的代码，并给编译好的二进制文件赋予 SUID 权限。</p>
<p>如果在服务器上编译，还要配环境，部署代码改变时还得重新编译；如果在本地编译，还得把编译好的文件传上去，改一点也得重新传，太麻烦，排除。</p>
</li>
<li><p>在 ASP.NET Core 应用内检测文件变化，一旦发生变化就主动退出，由 Docker 自动重启并应用更新。</p>
<p>我不希望在 ASP.NET Core 里添加太多与其应用无关的代码，如果有更好的方法就好了。</p>
</li>
<li><p>直接以部署用户的权限运行服务，这样就不用担心权限不足了。</p>
<p>不错的想法，我了解到 Docker 具有 <a target="_blank" rel="noopener" href="https://docs.docker.com/engine/security/rootless/">rootless mode</a>；顺藤摸瓜又了解到 systemd 也可以配置每用户的服务，干脆用 systemd 管理，不用 Docker 也不是不可以。</p>
<p>但是，rootless Docker 会有权限问题，如不能 ping、不能监听低位端口，需要额外添加权限。另外，文档中使用 rootless Docker 之前也需要先停止系统级的 Docker，我担心会冲突。</p>
<p>不用 Docker 又会带回配环境的问题，我在 apt 安装和手动安装 .NET 运行时之间犹豫了很久，还是希望有更好的办法。</p>
</li>
<li><p>不再在 Actions 中 SSH 连接服务器执行代码，而是构建 Docker image 上传到 Docker Hub，由 <a target="_blank" rel="noopener" href="https://github.com/containrrr/watchtower">containrrr&#x2F;watchtower</a> 自动更新映像。</p>
<p>是个不错的办法，唯一的缺点是新版本不是立刻生效，需要等 containrrr&#x2F;watchtower 主动检查。</p>
</li>
<li><p>不再在 Actions 中 SSH 连接服务器执行代码，而是改用 Webhook 触发服务器自己执行更新脚本。Webhook 后端可以由有权限的用户运行。</p>
<p>最终选定了这个办法。</p>
</li>
</ol>
<h3 id="Actions-artifacts-无法直接下载，需要配置-access-token"><a href="#Actions-artifacts-无法直接下载，需要配置-access-token" class="headerlink" title="Actions artifacts 无法直接下载，需要配置 access token"></a>Actions artifacts 无法直接下载，需要配置 access token</h3><p>我认为把构建好的二进制文件上传 artifacts，是比推送到另一分支更好的方式。但是，直接下载 artifacts 会收到“You must have the actions scope to download artifacts.”的错误，必须配置 access token 并授予访问 workflow 的权限。要授予 workflow 权限，只能同时授予访问所有（包括私有）仓库的权限，所以我放弃了这个想法，还是推送到了另一个分支。</p>
<h3 id="弯路部分的参考资料"><a href="#弯路部分的参考资料" class="headerlink" title="弯路部分的参考资料"></a>弯路部分的参考资料</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sparkdev/p/9651622.html">Linux 特殊权限 SUID,SGID,SBIT</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/security/rootless/">Run the Docker daemon as a non-root user (Rootless mode)</a></li>
<li><a target="_blank" rel="noopener" href="https://azure.microsoft.com/en-us/services/signalr-service/">Azure SignalR Service</a></li>
<li><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/dotnet/net-core-and-systemd/">.NET Core and systemd</a></li>
</ul>
</div><div class="tags"><a href="/tags/Linux/"><i class="fa fa-tag"></i>Linux</a><a href="/tags/GitHub/"><i class="fa fa-tag"></i>GitHub</a><a href="/tags/Webhook/"><i class="fa fa-tag"></i>Webhook</a><a href="/tags/systemd/"><i class="fa fa-tag"></i>systemd</a></div><div class="post-nav"><a class="pre" href="/2022/04/29/%E5%B0%86-Btrfs-root-%E5%88%86%E5%8C%BA%E8%BD%AC%E6%8D%A2%E4%B8%BA-subvolume/">将 Btrfs root 分区转换为 subvolume</a><a class="next" href="/2022/03/14/%E7%94%A8-Ubuntu-Cloud-Images-%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BA%91%E9%95%9C%E5%83%8F%EF%BC%88%E9%85%8D%E7%BD%AE-cloud-init-%E7%9A%84-NoCloud-%E6%95%B0%E6%8D%AE%E6%BA%90%EF%BC%89/">用 Ubuntu Cloud Images 制作自己的云镜像（配置 cloud-init 的 NoCloud 数据源）</a></div><div id="vcomment"></div><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == 'true' ? true : false;
var verify = 'false' == 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'eF5widAEDbOaAndcDJGQp7Rh-gzGzoHsz',
  appKey:'WyOY5xy1Lo6xy1FLLTbpkwEM',
  placeholder:'',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  path: 'bleatingsheep.org/_posts/用-GitHub-Actions-和-Webhook-自动构建并部署-ASP-NET-Core-应用.md',
  requiredFields: ['nick','mail']
})
</script></div></div></div><div class="pure-u-1 pure-u-md-4-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">bleatingsheep 的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>