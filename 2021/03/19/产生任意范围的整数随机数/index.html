<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>产生任意范围的整数随机数 | bleatingsheep 的博客</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="/js/lib/normalize.css"><link rel="stylesheet" type="text/css" href="/js/lib/pure-min.css"><link rel="stylesheet" type="text/css" href="/js/lib/grids-responsive-min.css"><link rel="stylesheet" href="/js/lib/font-awesome.min.css"><script type="text/javascript" src="/js/lib/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="/js/lib/clipboard.min.js"></script><script type="text/javascript" src="/js/lib/toastr.min.js"></script><link rel="stylesheet" href="/js/lib/toastr.min.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">产生任意范围的整数随机数</h1><a id="logo" href="/.">bleatingsheep 的博客</a><p class="description"></p></div><div id="nav-menu"><a href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-4-4"><div class="content_container"><div class="post"><h1 class="post-title">产生任意范围的整数随机数</h1><div class="post-meta">2021-03-19</div><a class="disqus-comment-count" href="/2021/03/19/%E4%BA%A7%E7%94%9F%E4%BB%BB%E6%84%8F%E8%8C%83%E5%9B%B4%E7%9A%84%E6%95%B4%E6%95%B0%E9%9A%8F%E6%9C%BA%E6%95%B0/#vcomment"><span class="valine-comment-count" data-xid="bleatingsheep.org/_posts/产生任意范围的整数随机数.md"></span><span> 条评论</span></a><div class="post-content"><p>有一天，我突然想验证一下 .NET 产生任意范围的整数随机数是不是保证完全等概率的。</p>
<span id="more"></span>

<h2 id="零"><a href="#零" class="headerlink" title="零"></a>零</h2><p>我们先讨论一下，如何用 0~(n-1) 的随机数生成器，生成 0~(m-1) 范围的随机数。</p>
<h3 id="最朴素的想法"><a href="#最朴素的想法" class="headerlink" title="最朴素的想法"></a>最朴素的想法</h3><p>先考虑 n&gt;m 的情形，最简单的做法是，先产生一个 0~(n-1) 的随机数，如果小于 m，就使用这个结果；如果大于等于 m，就重来。如果 n&gt;2m，可以目标范围的一个数对应原生成器的两个或以上的数。</p>
<p>至于 n&lt;m 的情况，可以多次生成来获得一个更大范围的生成器，比如生成两次就是 0~(n^2-1) 的随机数生成器。</p>
<h3 id="另外一种想法"><a href="#另外一种想法" class="headerlink" title="另外一种想法"></a>另外一种想法</h3><p>由于上面的那种想法没有完全利用产生的随机数，我希望能够产生尽量少的随机数达到目的。我首先考虑的是，把 [0,1) 分成更小的区间，比如 [0,1&#x2F;m), [1&#x2F;m, 2&#x2F;m), …。这些区间作为目标，同时划分出 [0,1&#x2F;n), [1&#x2F;n, 2&#x2F;n), … 这些区间。每生成一个随机数，就从后者当中选取一个区间。如果选中的区间是前面区间的子集，就取该区间对应的数字；如果不是，就继续划分为 n 个区间并且随机取一个。</p>
<p>这种想法在产生无限个随机数时，效率是最高的，因为所有信息都被用到了。但是只生成一个随机数时，却不如上面的。或者说，需要使用 0~(n-1) 的生成器的次数的期望更高。</p>
<p>举个例子，用 n&#x3D;8 的生成器，生成 m&#x3D;7 的随机数。按朴素的想法，每次有 1&#x2F;8 的概率需要再生成一次。但是按第二种想法，只有第一次产生 0 或 7 时，才只需要生成一次。从第二次开始，依旧每次有 1&#x2F;8 的概率需要再次生成。</p>
<h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><h3 id="NET-的-System-Random-类"><a href="#NET-的-System-Random-类" class="headerlink" title=".NET 的 System.Random 类"></a>.NET 的 <code>System.Random</code> 类</h3><p>现在我们来看 .NET 中的随机数。</p>
<p>.NET 内置了两个与产生随机数有关的类。一个是 <code>System.Random</code>，通过算法产生伪随机数；另一个实际上有至少两个相关类，用来产生无法预测的，可以用作加密用途的生成器。</p>
<p>先看 <code>System.Random</code>。这个类是这么定义的：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Random</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Random</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Random</span>(<span class="params"><span class="built_in">int</span> Seed</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> <span class="title">Next</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> <span class="title">Next</span>(<span class="params"><span class="built_in">int</span> maxValue</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">int</span> <span class="title">Next</span>(<span class="params"><span class="built_in">int</span> minValue, <span class="built_in">int</span> maxValue</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">NextBytes</span>(<span class="params"><span class="built_in">byte</span>[] buffer</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">NextBytes</span>(<span class="params">Span&lt;<span class="built_in">byte</span>&gt; buffer</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">double</span> <span class="title">NextDouble</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="built_in">double</span> <span class="title">Sample</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>Next(int maxValue)</code> 和 <code>Next(int minValue, int maxValue)</code> 包含 <code>minValue</code>，但均不包含 <code>maxValue</code>，前者默认 <code>minValue</code> 为 0。而 <code>Next()</code> 默认 <code>minValue</code> 为 0，<code>maxValue</code> 为 <code>int.MaxValue</code>（是的，范围比 <code>Int32</code> 可表示的范围的一半少 1）。</p>
<p>先看有趣的 <code>NextDouble()</code> 方法。这个方法产生一个大于等于 0 但小于 1 的随机浮点数。有些地方用这种方式产生一定范围内的整数</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Next</span>(<span class="params"><span class="built_in">int</span> maxValue</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">int</span>)Math.Floor(maxValue * NextDouble());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，这种方法只能近似等概率。这是因为，由于精度限制，能产生的不同的随机浮点数的个数是有限的，而每一个浮点数都会固定对应一个结果，这样就不能保证每个结果都对应同样个数的浮点数，因而概率不等。</p>
<h3 id="生成指定范围的随机数"><a href="#生成指定范围的随机数" class="headerlink" title="生成指定范围的随机数"></a>生成指定范围的随机数</h3><p>如果现在我告诉你，随机数生成器的底层是产生一堆随机比特，或者说，是第一位都等概率随机的 <code>System.UInt32</code>，让你去写产生指定范围随机数，即 <code>int Next(int minValue, int maxValue)</code>，你会怎么写？</p>
<p>最简单的办法，如果还是不考虑概率的微小差别，可以简单这么写</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Next</span>(<span class="params"><span class="built_in">int</span> minValue, <span class="built_in">int</span> maxValue</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Assert(minValue &lt; maxValue);</span><br><span class="line">    <span class="built_in">uint</span> range = maxValue - minValue;</span><br><span class="line">    <span class="keyword">if</span> (range == <span class="number">1</span>) <span class="keyword">return</span> minValue;</span><br><span class="line">    <span class="built_in">uint</span> rand = NextUInt32();</span><br><span class="line">    <span class="keyword">return</span> minValue + (<span class="built_in">int</span>)(rand % range);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了保证完全等概率，可以这么改写</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Next</span>(<span class="params"><span class="built_in">int</span> minValue, <span class="built_in">int</span> maxValue</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Debug.Assert(minValue &lt; maxValue);</span><br><span class="line">    <span class="built_in">uint</span> range = (<span class="built_in">uint</span>)(maxValue - minValue);</span><br><span class="line">    <span class="built_in">uint</span> max = (<span class="built_in">uint</span>)(((<span class="built_in">ulong</span>)<span class="built_in">uint</span>.MaxValue + <span class="number">1</span>) / range * range - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">uint</span> rand = NextUInt32();</span><br><span class="line">        <span class="keyword">if</span> (rand &lt;= max)</span><br><span class="line">            <span class="keyword">return</span> minValue + (<span class="built_in">int</span>)(rand % range);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，我们看一下<a target="_blank" rel="noopener" href="https://github.com/dotnet/runtime/blob/eceb5c8951ca3e5902a6eecdd594f82916ff4762/src/libraries/System.Private.CoreLib/src/System/Random.Xoshiro256StarStarImpl.cs#L113">.NET 中是如何实现的</a></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">Next</span>(<span class="params"><span class="built_in">int</span> minValue, <span class="built_in">int</span> maxValue</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">ulong</span> exclusiveRange = (<span class="built_in">ulong</span>)(maxValue - minValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exclusiveRange &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Narrow down to the smallest range [0, 2^bits] that contains maxValue.</span></span><br><span class="line">        <span class="comment">// Then repeatedly generate a value in that outer range until we get one within the inner range.</span></span><br><span class="line">        <span class="built_in">int</span> bits = BitOperations.Log2Ceiling(exclusiveRange);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ulong</span> result = NextUInt64() &gt;&gt; (<span class="keyword">sizeof</span>(<span class="built_in">ulong</span>) * <span class="number">8</span> - bits);</span><br><span class="line">            <span class="keyword">if</span> (result &lt; exclusiveRange)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="built_in">int</span>)result + minValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Debug.Assert(minValue == maxValue || minValue + <span class="number">1</span> == maxValue);</span><br><span class="line">    <span class="keyword">return</span> minValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>.NET 并没有使用乘、除算出范围，再用模确定数字，而是计算出需要的比特，并直接抛弃掉多余的。这么做可能是考虑到性能。</p>
<h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>在 .NET 中，还有一个类是与生成随机数有关的（确切地说，有多个类）。最主要的就是 <a target="_blank" rel="noopener" href="https://github.com/dotnet/runtime/blob/main/src/libraries/System.Security.Cryptography.Algorithms/src/System/Security/Cryptography/RandomNumberGenerator.cs#L11"><code>System.Security.Cryptography.RandomNumberGenerator</code></a>。从命名空间就可以看出来，这是用来产生可用于加密的随机数的。有趣的是，它用来<a target="_blank" rel="noopener" href="https://github.com/dotnet/runtime/blob/main/src/libraries/System.Security.Cryptography.Algorithms/src/System/Security/Cryptography/RandomNumberGenerator.cs#L11">生成给定范围随机数</a>的方法是通过位运算得到一个 <code>mask</code>，然后用按位与去取需要的比特，而 <code>System.Random</code> 是计算出需要的比特数，用位移取得需要的比特。</p>
</div><div class="tags"><a href="/tags/NET/"><i class="fa fa-tag"></i>.NET</a></div><div class="post-nav"><a class="pre" href="/2021/03/22/%E8%A7%A3%E5%86%B3%E8%85%BE%E8%AE%AF%E4%BA%91%E8%BD%BB%E9%87%8F%E8%87%AA%E5%B8%A6Ubuntu%E9%95%9C%E5%83%8F%E4%B8%8D%E5%A5%BD%E4%BD%BF%E7%9A%84%E9%97%AE%E9%A2%98/">解决腾讯云轻量自带Ubuntu镜像不好使的问题</a></div><div id="vcomment"></div><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == 'true' ? true : false;
var verify = 'false' == 'true' ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'eF5widAEDbOaAndcDJGQp7Rh-gzGzoHsz',
  appKey:'WyOY5xy1Lo6xy1FLLTbpkwEM',
  placeholder:'',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  path: 'bleatingsheep.org/_posts/产生任意范围的整数随机数.md',
  requiredFields: ['nick','mail']
})
</script></div></div></div><div class="pure-u-1 pure-u-md-4-4"><div id="footer">Copyright © 2022 <a href="/." rel="nofollow">bleatingsheep 的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=1.0.0"></script></div></body></html>